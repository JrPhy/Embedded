大家都知道在電路訊號中都是使用 01 紀錄資料，從 GPIO 就知道要如何將輸入的訊號化為 0 與 1，主要就是用低電位與高電位。所以就由 GPIO 再進一步訂出通訊協定，通訊協定常用的有 UART、I<sup>2</sup>C、SPI，這篇會著重於 GPIO 與 UART 通訊協定

## 一、GPIO
GPIO(General Purpose Input/Output)是一種泛用型的輸入輸出裝置，每個晶片會有不同的 GPIO 端口。除了單純的輸入輸出外，還可以組合成常見的通訊協定，如 I2C, SPI, UART...... 等。內部會連接電子元件，如電容、電阻與電晶體來保護整個系統。在 STM32 中分別支援四種輸入與四種輸出模式\
![image](https://wiki.st.com/stm32mcu/nsfr_img_auth.php/thumb/0/04/Package_MCU_blue.png/225px-Package_MCU_blue.png)
![image](https://github.com/JrPhy/Firmware/blob/main/pic/Basic_structure_of_a_standard_IO_port_bit.png.png)\
上圖中 VDD 為工作電壓，VSS 為接地

## 1. 輸入模式
當電流從外部流入 IC 稱為輸入，有上拉、下拉、浮空跟模擬，比較常用的是前面兩種。對應上圖的 input driver，也就是上方的虛線框。
#### 1. 浮空輸入
就是讓外部電流不經過 TTL 且兩電阻也斷路，此時電流會直接流入 IC，這種狀況會有較多的不穩定，通常不用
#### 2. 模擬輸入
就是浮空輸入的電流經過 TTL，會將類比訊號轉為數位訊號
#### 3. 上拉輸入
在上端的輸入端加入一個電阻，導通時會**提供**一個微小的電流，會讓輸入的電壓稍微提高，所以稱為**上拉**，其電阻稱為上拉電阻。
#### 4. 下拉輸入
與上拉相反，在上端的輸出端加入一個電阻，導通時會**流失**一個微小的電流，會讓輸入的電壓稍微降低，所以稱為**下拉**，其電阻稱為下拉電阻。

## 1. 輸出模式
上圖為一標準 I/O 端口，看到下方的 Output driver 虛線框框，裡面有三種狀態，分別是 Push-pull, Open-drain or disable。VDD 與 VSS 為中間串接了 P/N MOS。兩個 MOS 會組成四種狀態如下表，O 代表輸出

| O | 高電位 | 低電位 | 高阻抗 | 短路 |
| --- | --- | --- | --- | --- |
| P | 打開 | 關閉 | 關閉 | 打開 |
| N | 關閉 | 打開 | 關閉 | 打開 |

#### 1. Push-Pull (推挽輸出)
當兩個 MOS 都是打開時，電流會直接從 VDD 到 VSS，也就是直接短路燒毀，所以只剩前面三種狀態。而當 VDD 為開 VSS 為閉，那麼電流從 IC 往外流出去，稱為 Push，反過來則稱為 Pull。此種輸出的電壓由 VDD 決定。

#### 2. Open-drain (開漏輸出)
這時接 VDD 的 MOS 都是關閉的，電流就只會流入 IC，因為怕流入的電流過高燒壞 IC，一般會搭配一個上拉電阻來降低流入 IC 的電流。電阻大電流就小，驅動能力就弱，但是漏電流也小，電阻小的話則相反，需要計算後才能得到一個較佳的電阻值。此輸出通常用於不同電壓的場景，開漏輸出可以讓多顆 IC 同時接到外部的訊號，只需要將兩顆 IC 並聯即可達到此功能。

#### 3. 復用推挽輸出
需要用到線 AND，如 IIC
#### 4. 復用開漏輸出
用於電壓快速變換，如 UART，PWM。

## 二、UART
## 1. UART/USART
全名為 Universal Asynchronous Receiver Transmitter，在兩個系統中分別由 Tx 傳輸線與 Rx 與接收線連接，可以**同時接收與發送訊號**，若加上同步的方式，即為 Universal Synchronous Asynchronous Receiver Transmitter，需要多一根線來傳輸時鐘訊號來做同步，如 SPI。

| System 1 | UART | System 2 |
| --- | --- | --- |
| Tx | --> | Rx |
| Rx | <-- | Tx |

當然這個的缺點也很明顯，如果有很多儀器要互相傳遞數據，那就需要將每個儀器都接上兩條線，如果是都要回傳到主機上，那主機會需要接很多的線。而且這種傳輸的距離通常很短，沒有時鐘線的話就需要兩台儀器定在某個傳輸速率(baud)，來告訴雙方資料該如何讀取，但這個速率通常很低。根據以上缺點也演化出了不同的通訊協定

1. 傳輸距離不足 --> RS232/RS485 (算是介面標準)
2. 傳輸速率過低 --> 加時鐘線，捨棄起始與停止 SPI，其一對多也是要拉多根線
3. 一對多較複雜 --> 加時鐘線，並聯多個裝置 I<sup>2</sup>C，一對多也是要拉**一根線**

## 2. 傳輸協定
UART 在傳輸前電路為高電為，發送時會先將電位拉低表示要開始發送資料，接下來再將資料發送出去，最後回復高電位表示結束。通常傳輸時會將資料每 8 bit 為一個單位傳輸，也就是剛好 1 byte，之後再根據實際的資料型態去轉型。例如要發送 'A' 給另一設備，會先轉為 8 bit 的二進制 01000001，轉為電訊號即為```|_|‾|_ _ _ _ _|‾```，在包含起始位與停止位即為```|_ _|‾|_ _ _ _ _|‾ ‾```

![image](https://media.geeksforgeeks.org/wp-content/uploads/20220921105947/UARTdataformat-660x170.png)

在傳輸時需要有起始位與停止位，自然速率就不會高。而 SPI 多了個時鐘線做這件事，所以傳輸速率可以高很多。

#### 1. 鮑率(baud)
單位為 bit/s，也就是每秒傳多少個數據，兩個儀器需要**相同的**鮑率在讀取時才不會錯誤。以 RS232 為例典型的「鮑率」是300, 1200, 2400, 9600, 19200, 38400, 115200等。以 9600 為例，每傳輸 1 bit 費時約 104 us，但在實際電路中會因 V, I, R 三者大小不同，使得從低電位到高電位的時間有延遲，所以可以從 52 us 開始去取每位。

#### 2. 奇偶較驗
有時會為了檢查數據正確性，就在原始資料後一位另外做檢查，因為訊號只有 0/1，所以可以檢查 1 的個數，奇數個為 1，偶數個為 0，例如 'A' 的二進制有兩個 1，所以較驗位為 0。當然也有可能兩個資料出錯，但是機率非常的低，所以通常一位的奇數較驗就很夠用了。所以每一次傳輸通常是發送 10 ~ 11 bits，資料是在第 2 ~ 9 個 bit 中，第一個皆為起始位，若無較驗位則為 10 bits，有則為 11 bits。

## 3. 程式碼
在使用 SMT32 時通常會使用他們所提供的 HAL 函示庫，裡面已經實作傳出的相關函數，也會搭配牠們的 CubeMX IDE 來做開發。裡面發送的函數有三個，會在最後面加上 Transmit，也有對應的接收函數 Recieve。

#### 1. HAL_UART_Transmit :輪詢方式，阻塞式發送函數(必須等資料傳送完成後 MCU 才去做其他事情)
HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
```
//*huart : 看選擇哪個USART填入對應編號
//*pData : 要傳送的資料Buf指針
//Size : 資料長度
//Timeout : 逾時時間
```
在發送資料時，會把資料每 bit 放在 register 中，然後再由端口發送出去。因為是阻塞式的，會等所有訊息發完或超過逾時時間之後再去做其他事情，對應的阻塞是接收函數為 ```HAL_UART_Recieve(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)```

#### 2.HAL_UART_Transmit_IT : 中斷方式，非阻塞發送函數
```
//*huart : 看選擇哪個USART填入對應編號
//*pData : 要傳送的資料Buf指針
//Size : 資料長度
```
將資料放入 register，如果還沒發送出去，那就先去做別的事，等 register 空了後再把其他資料放進 register，就不需要一直等待。對應的阻塞是接收函數為 ```HAL_UART_Recieve_IT(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)```。使用非阻塞式發送與接收資料，因為資料還沒全部接收完，所以不能進行分析，所以就需要修改其對應的中段函數。
